
# 📌 K-평균 클러스터링(K-means Clustering)
<details>
<summary>내용보기 🔽</summary>
   
- 참고 : [내용](https://bkshin.tistory.com/entry/%EB%A8%B8%EC%8B%A0%EB%9F%AC%EB%8B%9D-7-K-%ED%8F%89%EA%B7%A0-%EA%B5%B0%EC%A7%91%ED%99%94-K-means-Clustering), [클러스터링 시각화 시뮬레이션](https://www.naftaliharris.com/blog/visualizing-k-means-clustering/)
- 클러스터란 비슷한 특성을 가진 데이터끼리의 묶음
- **비지도 학습** 알고리즘
- 클러스터링이란 어떤 데이터들이 주어졌을 때, 그 데이터들을 클러스터로 그룹화 시켜주는 것
   
## ✔ 프로세스
1. 얼마나 많은 클러스터가 필요한지 결정(`K` 결정)
2. 초기 `Centroid`(각 클러스터의 중심) 선택
   -  랜덤하게 설정
   -  수동으로 설정
   -  Kmean++ 방법
3. 모든 데이터를 순회하며 각 데이터마다 가장 가까운 `Centroid`가 속해있는 클러스터로 assign
4. `Centroid`를 클러스터의 중심으로 이동
5. 클러스터에 assign 되는 데이터가 없을 때까지 스텝 3,4를 반복

## ✔ K-means 단점
- 클러스터 개수(`K`)를 미리 지정해야 함 : 가장 큰 단점 중 하나. 사용자가 사전에 최적의 `K`값을 알기 어렵다.
- 초기 중심점 선택에 민감 : 초기에 어떤 데이터 포인트를 중심점으로 선택하느냐에 따라 최종 클러스터링 결과가 달라질 수 있다.
- 구형(Spherical) 클러스터에만 효과적 : 복잡하거나 길쭉한 형태의 클러스터에는 적합하지 않다.
- 이상치(Outlier)에 민감 : 데이터 분포에서 멀리 떨어진 데이터 포인트가 있을 경우, 중심점을 크게 이동시킬 수 있다.
- 데이터의 크기(Scale)에 민감 : 각 변수(특성)의 값 범위가 크게 다르면, 클러스터링 결과가 왜곡될 수 있다.

</details>

---

# 📌 지도 학습과 비지도 학습 알고리즘의 차이

<details>
<summary>내용보기 🔽</summary>
   
## ✔ 지도 학습 (Supervised Learning)
- '정답'이 있는 데이터를 학습하는 방식
- 주요 목적 : 새로운 데이터의 결과를 예측하는 것
- 예시 : K-NN, 의사결정나무, 서포트 벡터 머신 등
- '빨강'이라는 레이블이 붙은 데이터들을 학습하여, 새로운 데이터가 들어왔을 때 가장 비슷한 레이블로 예측하는 것

## ✔ 비지도 학습 (Unsupervised Learning)
- '정답'이 없는 데이터를 스스로 학습하는 방식
- 주요 목적 : 데이터의 구조나 패턴을 발견하여 새로운 인사이트를 얻는 것
- 예시 : K-평균 군집화(K-Means), PCA 등
- 온라인 쇼핑몰에서 고객들의 구매 기록을 분석하여 '자주 운동복을 사는 고객', '아웃도어 용품을 주로 사는 고객' 등 비슷한 성향을 가진 고객 그룹을 자동으로 나누는 것

</details>

---

# 📌 차선 색상 분류 실습 (K-means 활용)


## 1. 목표
- 시각적 결과: 원본이미지 , 결과이미지
- 색상 팔레트: 추출된 4가지 대표 색상
- 분포 차트: 각 색상이 차지하는 비율
- 상세 분석: BGR 값과 픽셀 수/비율 정보

## 2. 동작설명

### 1. 이미지 준비 및 ROI(관심 영역) 선택
- 이미지를 불러온 뒤 `cv2.selectROI` 함수를 통해 사용자가 분석을 원하는 특정 영역(ROI)을 직접 지정한다.
- 선택된 ROI의 좌표를 원본 이미지 크기에 맞게 다시 변환하여 원본 이미지에서 해당 ROI를 잘라낸다.
> <img width="350" height="411" alt="image" src="https://github.com/user-attachments/assets/920d3731-22b4-427c-a065-6b53e13a6fc2" />


### 2. K-means를 위한 데이터 준비
- 선택된 ROI 이미지를 BGR 색 공간에서 HSV 색 공간으로 변환
- 이미지의 픽셀 데이터를 K-means 알고리즘에 입력하기 위해, roi_hsv 이미지를 (픽셀 수, 3) 형태의 2차원 배열로 변환한다.
  
### 3. K-means 클러스터링
- `cv2.kmeans` 함수를 사용하여 K-means 클러스터링을 실행
- `K=4`로 설정하여 ROI 내의 모든 픽셀들을 4개의 주요 색상 그룹으로 묶는다.
- 분석을 위해 HSV 중심점들을 다시 BGR 색상으로 변환한다.
  
### 4. 클러스터링 이미지 생성 및 분석
- 각 픽셀이 어떤 클러스터에 속하는지를 나타내는 labels 배열을 사용하여, 원본 ROI의 각 픽셀을 해당 클러스터의 대표 색상(중심점)으로 대체한다.
- `np.bincount`를 사용하여 각 클러스터에 속한 픽셀의 수를 세어, 각 색상이 전체 이미지에서 차지하는 비율을 계산한다.
- 분석된 대표 색상의 BGR 값, 픽셀 수, 그리고 비율을 출력한다.

### 5. 시각화
- `matplotlib`을 사용하여 분석 결과를 시각화
> <img width="500" height="600" alt="image" src="https://github.com/user-attachments/assets/7afbc4e1-8a1c-417f-8a80-56b7a6a97cb6" />

  
## 3. 실행
```bash
#./src/
python load_line_color.py
```

</details>

---

# 📌 K-최근접 이웃(KNN)


<details>
<summary>내용보기 🔽</summary>
   
- 참고 : [내용](https://bkshin.tistory.com/entry/%EB%A8%B8%EC%8B%A0%EB%9F%AC%EB%8B%9D-6-K-%EC%B5%9C%EA%B7%BC%EC%A0%91%EC%9D%B4%EC%9B%83KNN?category=1057680)
- 머신러닝에서 가장 간단하고 직관적인 **지도 학습** 알고리즘
- 주로 분류(Classification) 문제에 사용되며, 회귀(Regression)에도 활용할 수 있다.
- 어떠한 데이터가 주어지면 해당 데이터의 주변(이웃)의 데이터를 살펴본 뒤 더 많은 데이터가 포함되어 있는 범주로 분류하는 방식

## ✔ 프로세스
새로운 데이터가 주어졌을 때, 기존 데이터 중에서 가장 가까운(유사한) K개의 데이터를 찾아보고, 이웃 데이터들이 속한 그룹을 기준으로 새로운 데이터의 그룹을 결정한다.
1. 거리측정 : 새로운 데이터와 학습된 데이터 간의 거리를 계산
   - 유클리드 거리
   - 맨해튼 거리
2. `K`개의 이웃 선택 : 계산된 거리를 기준으로 가장 가까운 `K`개의 이웃 데이터 선택
3. 다수결 투표 : 가장 많은 표를 얻은 데이터를 새로운 데이터의 예측 결과로 결정


## ✔ KNN 단점
- 데이터의 양이 많아질수록 거리 계산량이 늘어난다.
- 데이터의 특성(Feature) 스케일에 매우 민감
- 데이터의 차원이 커질 수록 성능 저하 가능성 높음

</details>

---

# 📌 웹캠 실시간 의류 분류기 (K-NN 알고리즘 기반)

<details>
<summary>내용보기 🔽</summary>
   
## 1. 목표
- K-NN 알고리즘 학습을 위한 데이터셋 파일을 생성한다.
- 데이터 전처리를 통해 최적의 K값을 탐색한다.
- 웹캠으로 촬영한 옷의 색상을 실시간으로 K-NN 알고리즘으로 자동 분류한다.

## 2. 동작설명

### 동작 요약 흐름
```css
[CSV 데이터 로드] → [HSV 값 정규화] → [KNN 학습]
           ↓
      [웹캠 캡처 시작]
           ↓
    [ROI 설정 및 추출]
           ↓
    [HSV 평균값 계산]
           ↓
    [정규화된 샘플 생성]
           ↓
    ┌─────────────────────────────┐
    │   KNN 예측 (k=3) 수행      │
    │   ───────────────────────   │
    │   • 예측 라벨 확인          │
    │   • 신뢰도 계산             │
    └─────────────────────────────┘
           ↓
 [웹캠 화면에 예측 결과 표시 + Matplotlib로 확률 바 차트 출력]

```


### 1. 데이터셋 생성
- 웹캠을 실행한 뒤 의류 종류를 학습시킨다.
- 마우스로 학습 데이터 클릭 후 라벨(1~2)에 저장
- 학습 데이터는 `s` 키를 눌러 `.csv` 형태로 저장
> <img width="400" height="235" alt="image" src="https://github.com/user-attachments/assets/70d6f7d6-939a-493d-a0f3-74dedc48813d" />

### 2. HSV 값 정규화 / 라벨 인코딩
- KNN 학습에 사용하기 위해 HSV 값을 0~1 범위로 정규화
- 문자열 라벨을 숫자 라벨로 변환

### 3. KNN 학습
- OpenCV `cv2.ml.KNearest_create()` 사용
- 훈련 데이터(X), 라벨(y_numeric)로 학습 수행

### 4. ROI(관심영역) 설정 및 조작
- 웹캠 화면에서 **사각형 ROI(100×100 기본)**가 표시되며:
   - 드래그 → ROI 위치 이동
   - + 키 → ROI 크기 증가
   - - 키 → ROI 크기 감소
- ROI 내부의 평균 색상(HSV)을 추출하여 예측에 사용

### 5. 실시간 색상 추출 및 예측
- BGR → HSV 변환
- HSV 평균값 계산
- 정규화 후 KNN 예측

### 6. 결과 시각화
- 웹캠 화면에 예측 결과(의류 종류) 텍스트 출력
```python
cv2.putText(frame, f"Cloth : {predicted_label}", ...)
```
- 각 클래스별 예측 확률(%) 실시간 바 차트로 표시
```python
plt.bar(labels_unique, probs * 100)
```

## 3. 결과

roi의 위치를 조정해서 모자와 티셔츠 영역을 인식하면 학습 데이터에 따라
모자와 티셔츠를 출력한다.

#### roi 모자 위치
> <img width="226" height="241" alt="image" src="https://github.com/user-attachments/assets/90ed729e-e79f-4beb-9486-3c655c986ce5" />

#### roi 티셔츠 위치
> <img width="252" height="151" alt="image" src="https://github.com/user-attachments/assets/0beca38f-8a89-4525-97a0-8858aaf758ab" />



## 4. 실행
```bash
# /src
# 데이터셋 생성
python clothes_data.py

# 정확도 측정
python clothes_mnist.py

# 웹캠 실시간 의류 분류
python clothes_test.py
```

